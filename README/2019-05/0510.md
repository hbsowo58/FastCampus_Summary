죽었어 = 잊혀졌어

웹은 퍼포먼스보다 메모리를 중요하게 여기기

자바스크립트,엔진의 내부동작 돌아가는것알기

프레임워크는 쓰는 방법만알기 (언제 없어질지 모름)

같은 문법지식을 안다는 가정하에, 메소드를 많이알고 사용하는사람이 잘함

'말이통하는지를 제일먼저봄'

공부하는 방법:모르는게 나온다, 잠깐 넘어갔다가 다시돌아옴

한권을 완독후 -> 빈 부분 찾는식 (열댓번)

말귀를 알아들으려면 이것도 알고 저것도알아야함



전역변수 문제점

중복선언 될 수 있음

생명주기 불사(자바스크립트 로드되서, 런타임이전에 생성,안죽음)

누구든지 접근가능(누구든지 수정가능)

스코프체인에서 종점(가장 참조하는데 느림)

네임 스페이스 오염(전역변수 x, 다시는 x라는것 쓸 수 없음)



->let과 const가 나온 이유

챕터 1~14 변수에 관한 이야기

foo(); 함수호출 표현식 (다만 변수에 담지 않았다





function foo() {
  var x = 'local';
  console.log(x); // local
  return x;
}

foo();
console.log(x); // ReferenceError: x is not defined

foo를 전역스코프(렉시컬환경)의 전역객체에 저장

변수선언 x 지역스코프의 지역객체에 저장

콘솔찍고

x반환

foo()함수호출표현식 local

console.log(x)전역객체에서 찾아보나 없음 래퍼런스에러

스코프에 등록= 생성 스코프의 소멸 = 삭제



스코프를 좁게 만들 수록 좋다(변수가 태어나고 얼마지나지 않아죽인다)



패턴=꼼수 프로그래밍은 이론/코딩스킬로 나누기







var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

num을찍어도 사라지지 않는 이유:클로져

ㅡㅡㅡㅡㅡㅡㅡㅡㅡ

var counter = {

​	num:0.

​	increase(){

​	return ++this.num;}

​	decrease(){

​	return --this.num;}

}

counter.num = true (직접접근할 수 있다)

퍼블릭 문제(바꾸라고 만들어놓은거아니냐)

보호하고 싶은 정보를 밖에 안알리는것(캡슐화, 인포메이션 하이딩)

중첩함수가 외부함수보다 오래살아남은경우 (클로져)

자바스크립트에서 함수객체는 생성될'때' 함수 객체만이 갖는 내부 슬롯이 있고 자신이 생성될때의 외부 스코프를 담아둔다(렉시컬 스코프)



자바스크립트는 클로저의 존재가 있어서 캡슐화를 지원안한다



모듈:import, export -> 웹팩으로 모듈 동작가능webpack+ babel

자바스크립트의 큰 문제(전역스코프가 하나다)

ㅡ>여러개 파일이 있어도 파일별로 스코프를 가지지 않는다! 파일을 쪼개도 의미가 없다! ㅡ>모듈화가 안된다



ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ전역변수를 쓰지말자라는 말을할려고 위에 내용을함ㅡㅡㅡㅡㅡㅡㅡㅡ



var의 문제

for문if문에서 선언해봤자 전역변수다

변수호이스팅



let

1변수선언중복xxx

var foo=123;

var foo=456;



var foo=123;

​     foo=456; 처럼 동작

2블록레벨스코프(모든 블록 스코프로 지정)



var쓸시절엔 전역,지역밖에없지만

let 을쓰면 전역,지역,블록 스코프



3변수 호이스팅 안되는 것'처럼'

var만 undefined로 초기화

let은 초기화x



var= 선언단계,초기화까지 한번에다

let은=선언만 하고 초기화x 일시적사각지대



var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 변수(“12.8 암묵적 전역 변수” 참고) 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

ex)settimeout ,alert 정석은 window.alert window.settimeout(전역객체의 메소드,전역함수다라고 부름)



const

하나빼고, let과 동일(재할당 불가)

let x; (선언만하고 할당안할수 있음)

const y (error)



const를 상수가 아닌것에도 사용한다

객체를 변수에 담으면 재할당할일이 그리 많지않음



var let 혼용금지



일단 const쓰고, 에러면 let

const써야되는데 let, let써야되는데 var쓰면 감점

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

프로퍼티를 정의한다 

정의= 식별자의 정체를 알리는것.

프로퍼티 의 정체를 알리는것

console.log(Object.getOwnPropertyDescriptor(o, 'a'));

a프로퍼티는 {value: 1, writable: true, enumerable: true, configurable: true}

값이 1이고, 갱신가능하고, 열거가능하고, 재정의가능하다



내부슬롯/내부메소드



프로퍼티 종류2개 데이터프로퍼티(value),접근자 프로퍼티(un value)

데이터프로퍼티:일반적인 프로퍼티다

접근자 프로퍼티:다른 데이터 프로퍼티 값을 조작한다(함수느낌)



ㅡㅡㅡㅡㅡㅡㅡㅡ16 객체시작 ㅡㅡㅡㅡㅡㅡㅡㅡ

# 생성자 함수(construct)

객체를 만드는방법 (차이를 알기)

1.객체 리터럴

한개씩 만든다 <-> 여러개 만들떄 생성자 함수

2.함수,메소드

기본적으로 생성자 함수 앞에는 new연산자 붙인다



원시값을 객체처럼 사용하면 원시값을 객체로 바꾼다

const str = 'Hi';

console.log(str.toLocaleLowerCase()); =wrapper 객체



new Number('123'); 형변환의 예 문자열을 숫자열로 =wrapper 객체

결론:object생성자 함수는 빈객체를 만든다.

리터럴을 쓰면 더편한데, object생성자 함수는 유용해보이지 않는다.



생성자 함수가 만들어낸객체 : 인스턴스

empty = new object() <-생성자 함수 

리터럴로 만든것은 그냥 객체를 만들었다고 하지 인스턴스라고 하기엔 애매하다

자바스크립트가 제공하는 생성자 함수 : 빌트인 



객체 리터럴에 의한 객체 생성 방식의 문제점

(중복해결 - 프로토타입)



new Circle(5); new가 없으면 일반호출 ,암묵적할당안일어남

new를 붙여야됨 this는 window가됨



this의 기본은 window

메소드로써 호출하면 메소드 앞에

생성자함수면 , 미래에 생성할 인스턴스  (new와 함께 호출)



[[]] 내부..

일반객체 =호출 x 내부메소드 없음 

함수객체=호출o 내부메소드 있음

일반함수 call 



모든함수는 [[call]] 호출 가능(왜냐, 일반적으로 호출가능하니까)

단, 생성자함수로 호출할 수 있는 함수는 정해져있음(ex화살표함수,메소드축약표현)

const arrow = () => {}



