
Memory leak 렉 - 메모를 업그레이드 해주면 줄어든다

원시타입과 객체는 다르다

이뮤터블 vs 뮤터블

값이 변한다는게 뭐냐? 값이 안변한다는게 뭐냐?

수학적 상수로 생각하면 안됨

값을 가지고 있을 수 있으면 변수

변수 상수와 이뮤터블 뮤터블은 구분해서 생각해야된다

상수의 구분 단위는 : 재할당이 가능한가 아닌가지 값이 변하냐 안하냐가 아니다

ㅡ>ex)재할당이 아닌행위를 통해 (객체) 변한 경우

대부분언어는 문자열을 객체나 배열로 다루는데, (몇글자가 될지 모른다)

변수는 프로그래밍에서 좋다고 말할 수 없다(에러가 나올 가능성이 많다)

자료형이 다르거나, 예상한 값이 안나온다

변수를 최대한 적게 사용하는게 좋다

꼭 써야되는 경우면 전역변수보다 지역 변수로 쓰고 없애지는게 낫다(스코프를 좁게)

스코프가 적다 = 변수의 값을 변경할 가능성(찬스)가 적다

재할당만 안되면, 변수의 값이 절대 안변한다

요즈음에는 객체도 원시값처럼 얼려서 사용한다 - 많이 경험을 해보았기 때문에

var foo = 10; var bar = foo;

foo = 100; console.log(bar); // ?

서로 별개의 값이라, 변화 x

인간관계처럼 혼자 살면 편하지만, 많으면 피곤해짐

객체:순서x 배열 순서 on

var person = { name: 'Lee' };

person을 선언한다 ( 파싱타임)

person을 찾는다 (있는지) 여기서 에러나면 참조에러

person에는 참조값을 갖는다

이방법을 쓰는 이유는 - 공유하려고

{ name: 'Lee' } 이건 리터럴이다. 아직 평가 되지 않았다 -> 1011010으로 평가되어야 한다

person이 갖고있는 참조값은 변하지 않았다(참조값은 원시값(숫자값)이라서)

객체는 참조값을 갖고 있기 때문에 (공유) 할 수 있다

console.log(person1 === person2); // ① 객체비교는 참조값이 같아야 트루, 여기선 폴스

console.log(person1.name === person2.name); // ② 원시값 비교 트루

얕은 복사(shallow copy)와 깊은 복사(deep copy)

참조 값을 복사하는 것을 얕은 복사(shallow copy), 원시 값처럼 객체 자체를 복사하여 다시 생성하는 것을 깊은 복사(deep copy)라 한다.

객체를 똑같은 친구를 만들어서 복사하는 것

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

상자함, 숫자수 (재사용하기위해서 -> 유지 보수성 증가 실수줄고 품질좋아지고 돈도적게듬)

입력과 출력이 존재

매개변수(함수밖의 값을 안으로 넣어준다)

함수호출에서 값을 (인수)

함수 선언문(Function Declaration/Function Statement)

함수명으로 식별자를 만들어서 실행컨텍스트에 등록(변수가 있는것처럼)

그후 함수를 객체화시켜서 만듬, 함수명으로 객체화시킨 것을 가리킴

함수 호이스팅을 한다

함수 표현식(Function Expression)

위에는 선언문, 이것은 할당문

변수 호이스팅을 한다

Function 생성자 함수(Function Constructor)

이런게 있나보다, 쓰면안됨

화살표 함수(Arrow Function): ES6

나중에 설명 (this)

선언문과 표현식을 대체하라고 만든게 아님(대체하는 타이밍 이있음 아무때나 xx)

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

함수선언문 -> 제대로되면 undefined

함수호출을 한다는것은 암묵적으로 변수명을 호출하는것이고

함수명은 내부블록내에서만 사용가능해서 (재귀함수 쓸때 사용한다)

함수는 객체다 (다른언어에서는 아니다)

함수표현식은 변수 선언 + 변수 할당문으로 이루어짐 - 선언처리부터 초기화를 undefined / 변수 호이스팅을 함(선언/ 초기화가 따로됨)

함수선언문은 내부에서 식별자에 함수 객체를 담아버림 (선언 + 초기화가 한번에 이루어짐)

결국 함수표현식으로 정의한 문은 함수 호출을 undefind() - add is not a function

함수 선언문으로 선언문보다 호출을 먼저하면 함수호이스팅에 의해 (undefined가 안들어있음) 잘동작

일반객체 :호출할 수 없다

함수객체:호출할 수 있다

인수:argument

인자:parameter(매개변수) 스코프가 함수 몸체

매개변수의 개수: 0개, 적을수록 좋고 3개가 넘어가면 객체를 넘기는게 좋음

return 문은 값을 반환한다, 함수 실행을 종료한다

함수명이 있는 기명 즉시 실행 함수도 사용할 수 있다. 하지만 함수명은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다. (단한번 호출)

ㅡㅡㅡㅡㅡ

중첩함수

함수안에 함수정의 외부함수를 도와준다(내부함수가 헬퍼함수의 성격을 갖는다)

한함수가 인수에 따라서 하는 행위가 바뀜(보조함수) -콜백함수

중첩함수와 콜백함수의 차이: 바꿔 낄 수 없다, 외부함수를 밖에서 상황에 따라 넣는다

ㅡㅡㅡㅡㅡㅡ

스코프

식별자가 다른코드에 의해서 참조 될 수 있느냐 없느냐

ㅡ>실행환경의 렉시컬환경이라는게 있고 그안에 환경레코드라는게 있는데 스코프의 구현이다

스코프라는 것은 곧 자료구조다 식별자와, 그현재값을 관리하는 자료구조다 (애를 자바스크립트엔진이 관리한다)

name binding(식별자와 값을 묶는다) 식별자 (css) 값(html)

스코프는 여러개가 있고, 상하 관계가 있다

변수는 어디에든 선언될 수 있으나 var로 선언된것은 블록레벨 스코프를 지원x

ex)if문내에서 작성해도, 스코프를 만들지는 않는다 let,const는 블록레벨 지원함

함수에서 선언한 변수는 지역스코프를 가지며, 선언한 함수 또는 하위스코프에서 쓸 수 있다.

상위스코프는 하위스코프 것을 사용하지 못한다.

즉, 스코프란 자바스크립트 엔진이 참조할 변수를 검색할 때 사용하는 규칙

스코프는 함수단위로 만들어지고, 중첩이 있기때문에 계층적구조를 갖고, 이것을 스코프 체인이라 한다.

함수가 어디서 선언됬느냐에 따라 호출따지지 않고 상위스코프를 기억하고 있는

다


