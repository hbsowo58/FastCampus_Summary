공부는혼자 하는것이다 , 그런데 요즈음 사람들은 학원을 다니느라 혼자공부하는 방법을 모르는 것 같다.

회사에서부터 공부하는것이 진짜고, 공부할려면 비빌언덕이 필요한데 그 언덕이 지금까지 배운지식이다

 어려워도 익숙해질때가 온다. 익숙해질때까지 읽어라



클로저: 외부함수와 중첩함수가 존재할때, 외부함수의 실행컨텍스트가 먼저 반환되어도

외부함수의 자유변수를 내부함수가 참조하고 있어서 중첩함수의 상위 렉시컬환경인 자유변수에 접근해 변수에 변경이 가능한 함수, 외부함수에서 내부함수를 반환하는 함수



외부함수보다 내부함수(중첩함수)가 더 오래 유지되는 경우 외부함수 밖에서 중첩함수를 호출해도

외부함수의 지역변수에 접근할 수 있는 함수 



선행조건: 함수가 일급객체를 가진 언어(왜냐면 외부함수에서 내부함수를 리턴해야되는데)

일급객체는 '함수를 ' 파라미터로 받거나 리턴할 수 있는 조건을 가지니까



함수 정의는 평가되어 함수 객체를  생성한다.





ㅡㅡㅡㅡㅡ실행컨텍스트



function foo(){

​	console.log(x);

}

object.prototype.x = 1;

foo();



변수는 스코프체인에서 찾지만 prototype은 프로토타입체인에서 찾는다

object.prototype.x = 1;

기본적으로 자바스크립트엔진은 프로퍼티에 접근하면 모든 객체가 가지고있는 

내부메소드 [[GET]]을 불러서



프로토타입체인과 스코프체인은 협력하는 애들이다 (둘다 협력해서 값을 평가한다)





'블록은 실행가능한 코드로 취급하지 않는다' 실행컨텍스트를 만드는게 아니라

환경을 만든다.





클로저는 쉽다. 실행컨텍스트를 알면

클로저의 목적: '상태유지'

몰라도 전역변수에 상태유지를 시키면 된다(안전하게는 못씀)

다른것들이 '접근하는것을 ' 방지해야한다. 접근할 수 있다는 이야기는 변경시킬 수 있다는것이다

다른 상태유지 방법: 프로퍼티

const O  = {

​	name: 'lee'

​	sayHi(){

​	log(this.name)}

}

o.sayHi() = lee

O.name 으로 변경가능 (객체의 모든 프로퍼티는 퍼블릭하기때문에 )



실행컨텍스트의 관점에서 대답하면 된다

함수형프로그래밍을 안다면 - > 하스켈을 배우는게 나음 (함수형을 위한 언어)



렉시컬이 들어가면 (정의 위치)



화살표함수의 렉시컬 this (화살표 함수가 있는곳 바로 위에 있는 상위의 this가 화살표함수의 this)



클로저라고 부르지않을떄

1.중첩함수가 부모의 상위 식별자를 참조하지 않을떄

2.중첩함수의 생애주기가 부모랑 같이 죽는다



-> 중첩함수가 외부함수의 생애주기보다 길면서 외부함수의 식별자를 참조할때



클로저는 상태를 안전하게 유지하기 위해 사용한다(상태가 의도치 않도록 은닉)

->최신상태 유지한다 은닉은 부차적인것이다. 상태를 유지하는것이 본질적인것이다



리턴은 한번밖에 못하기 떄문에 여러개를 리턴하려면 자료구조에 담아서 리턴









